package lambda_log

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"regexp"
	"strconv"
	"strings"
	"time"

	cwTypes "github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs/types"
	"github.com/turbot/tailpipe-plugin-sdk/mappers"
)

type LambdaLogMapper struct {
}

func (m *LambdaLogMapper) Identifier() string {
	return "lambda_log_mapper"
}

// JSON format for system logs as described in AWS docs
// Contains "time", "type", and "record" fields
// System logs are sometimes known as platform event logs
// https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs-advanced.html#monitoring-cloudwatchlogs-logformat
type jsonFormatSystemLog struct {
	Time   string                 `json:"time"`
	Type   string                 `json:"type"`
	Record map[string]interface{} `json:"record"`
}

// JSON format for application logs as described in AWS docs
// Contains "timestamp", "level", "message", and "requestId" fields
// Generated by Lambda functions using supported logging methods
// https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs-advanced.html#monitoring-cloudwatchlogs-logformat
type jsonFormatApplicationLog struct {
	Timestamp string `json:"timestamp"`
	Level     string `json:"level"`
	Message   string `json:"message"`
	RequestID string `json:"requestId"`
}

// While storing the logs in the S3 bucket, the logs are stored in the following format:
type s3FormatLog struct {
	AccountId *string `json:"accountId"`
	LogGroup  *string `json:"logGroup"`
	LogStream *string `json:"logStream"`
	Id        *string `json:"id"`
	Timestamp *int64  `json:"timestamp"`
	Message   *string `json:"message"`
}

func (m *LambdaLogMapper) Map(_ context.Context, a any, _ ...mappers.MapOption[*LambdaLog]) (*LambdaLog, error) {
	row := &LambdaLog{}
	isCwLog := false

	var raw string
	// Declare s3Format and isTextFormat at the start for use in lambda log stored in S3 bucket handling
	s3Format := &s3FormatLog{}
	isTextFormat := true

	switch v := a.(type) {
	case []byte:
		raw = string(v)
	case string:
		raw = v
	case *string:
		raw = *v
	case cwTypes.FilteredLogEvent:
		raw = *v.Message
		t := time.UnixMilli(*v.Timestamp)
		row.Timestamp = &t
		isCwLog = true
	default:
		return nil, fmt.Errorf("expected string or []byte, got %T", a)
	}

	// --- Lambda log stored in S3 bucket handling ---
	// If the log is in the format stored in an S3 bucket, unmarshal and extract timestamp, log group, and message
	if err := s3Format.UnmarshalJSON([]byte(raw)); err == nil && !isCwLog {
		t := time.UnixMilli(*s3Format.Timestamp)
		if err == nil {
			row.Timestamp = &t
		}

		if s3Format.LogGroup != nil {
			row.LogGroupName = s3Format.LogGroup
		}

		// Try to unquote the message (if it's a string)
		msgStr, err := strconv.Unquote(*s3Format.Message)
		if err == nil {
			isTextFormat = true
			raw = strings.TrimSpace(msgStr)
		}
		if err != nil {
			// If message is a JSON object, unquoting will fail; treat as JSON
			isTextFormat = false
			raw = strings.TrimSpace(*s3Format.Message)
			parsedData := isParsableJson(raw)
			if parsedData != nil {
				data := *parsedData
				if v, ok := data["message"].(string); ok {
					onlyMessageParsable := isParsableJson(v)
					if onlyMessageParsable != nil {
						row.MessageJson = *onlyMessageParsable
					} else {
						row.Message = &v
					}
				}
			}
			slog.Error("Error unquoting message", "error", err)
		}
	}

	// --- Main log parsing logic ---
	raw = strings.TrimSpace(raw)
	parsableJsonData := isParsableJson(raw)
	// Handle plain text system logs (START, END, REPORT, etc.) that are not JSON
	if (strings.HasPrefix(raw, "REPORT") || strings.HasPrefix(raw, "END") || strings.HasPrefix(raw, "START") || strings.HasPrefix(raw, "INIT_START") || strings.HasPrefix(raw, "EXTENSION") || strings.HasPrefix(raw, "TELEMETRY") || (isTextFormat && !isTimestamp(strings.Fields(raw)[0]) && !strings.HasPrefix(raw, "["))) && parsableJsonData == nil {
		lambdaLog, err := parseLambdaPainTextLog(raw, row)
		if err != nil {
			return nil, fmt.Errorf("error parsing lambda pain text log: %w", err)
		}
		lambdaLog.Timestamp = row.Timestamp
		lambdaLog.RawMessage = &raw
		parsedData := isParsableJson(raw)
		if parsedData != nil {
			data := *parsedData
			if v, ok := data["message"].(string); ok {
				lambdaLog.Message = &v
			}
			if v, ok := data["requestId"].(string); ok {
				lambdaLog.RequestID = &v
			}
			if v, ok := data["level"].(string); ok {
				lambdaLog.LogLevel = &v
			}
			lambdaLog.MessageJson = *parsedData
		}
		return lambdaLog, nil
	}

	// --- JSON log detection and parsing ---
	var probe map[string]json.RawMessage
	if err := json.Unmarshal([]byte(raw), &probe); err == nil {
		// System log (platform event) JSON
		if _, hasType := probe["type"]; hasType {
			var systemLog jsonFormatSystemLog
			if err := json.Unmarshal([]byte(raw), &systemLog); err != nil {
				return nil, fmt.Errorf("error unmarshalling as system log: %w", err)
			}

			// Parse timestamp and type
			if t, err := time.Parse(time.RFC3339, systemLog.Time); err == nil {
				row.Timestamp = &t
			}
			row.LogType = &systemLog.Type

			// Extract requestId and metrics if present
			if requestId, ok := systemLog.Record["requestId"].(string); ok {
				row.RequestID = &requestId
			}
			if metrics, ok := systemLog.Record["metrics"].(map[string]interface{}); ok {
				if v, ok := metrics["durationMs"].(float64); ok {
					row.Duration = &v
				}
				if v, ok := metrics["billedDurationMs"].(float64); ok {
					row.BilledDuration = &v
				}
				if v, ok := metrics["memorySizeMB"].(float64); ok {
					mem := int(v)
					row.MemorySize = &mem
				}
				if v, ok := metrics["maxMemoryUsedMB"].(float64); ok {
					mem := int(v)
					row.MaxMemoryUsed = &mem
				}
			}

			// Attach full JSON as RawMessageJson
			jsonLog := convertRawMessageMap(probe)
			if jsonLog != nil {
				row.RawMessageJson = *jsonLog
			}

			// Extract message as JSON or string
			if msg, ok := (*jsonLog)["message"]; ok {
				parsedData := isParsableJson(msg)
				if parsedData != nil {
					row.MessageJson = *parsedData
				} else {
					str, ok := msg.(string)
					if ok {
						row.Message = &str
					}
				}
			}

			row.RawMessage = &raw
			return row, nil
		} else if _, hasLevel := probe["level"]; hasLevel {
			// Application log (JSON format)
			var appLog jsonFormatApplicationLog
			if err := json.Unmarshal([]byte(raw), &appLog); err != nil {
				return nil, fmt.Errorf("error unmarshalling as application log: %w", err)
			}

			if t, err := time.Parse(time.RFC3339, appLog.Timestamp); err == nil {
				row.Timestamp = &t
			}
			row.LogLevel = &appLog.Level
			row.RequestID = &appLog.RequestID

			jsonLog := convertRawMessageMap(probe)
			if jsonLog != nil {
				row.RawMessageJson = *jsonLog
			}

			if msg, ok := (*jsonLog)["message"]; ok {
				parsedData := isParsableJson(msg)
				if parsedData != nil {
					row.MessageJson = *parsedData
				} else {
					str, ok := msg.(string)
					if ok {
						row.Message = &str
					}
				}
			}

			row.RawMessage = &raw
			return row, nil
		}
	}
	if len(strings.Fields(raw)) >= 4 && (isTimestamp(strings.Fields(raw)[0]) || isTimestamp(strings.Fields(raw)[1])) {
		// plain text application log
		// Handle plain text application logs (format: timestamp requestID logLevel message)
		// Example: 2024-10-27T19:17:45.586Z 79b4f56e-95b1-4643-9700-2807f4e68189 INFO some log message
		// [INFO]	2025-05-26T06:42:27.551Z	66e2e287-e14b-471e-8185-faca26d2c310	This is a function log
		fields := strings.Fields(raw)
		// Try to parse timestamp from first or second field
		if t, err := time.Parse(time.RFC3339, fields[0]); err == nil {
			row.Timestamp = &t
		}
		if t1, err := time.Parse(time.RFC3339, fields[1]); err == nil {
			row.Timestamp = &t1
		}

		// Extract log level and request ID
		uuidRegex := regexp.MustCompile(`[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}`)
		logLevelRegex := regexp.MustCompile(`\[?(INFO|DEBUG|WARN|ERROR|FATAL|TRACE)\]?`)

		if logLevelMatch := logLevelRegex.FindStringSubmatch(raw); len(logLevelMatch) > 1 {
			row.LogLevel = &logLevelMatch[1]
		}
		if uuidMatch := uuidRegex.FindString(raw); uuidMatch != "" {
			row.RequestID = &uuidMatch
		}
		if len(fields) >= 4 {
			msg := strings.Join(fields[3:], " ")
			parsableJsonMessage := isParsableJson(msg)
			if parsableJsonMessage != nil {
				row.MessageJson = *parsableJsonMessage
			} else {
				row.Message = &msg
			}
		}
		row.RawMessage = &raw
	}

	return row, nil
}

func convertRawMessageMap(probe map[string]json.RawMessage) *map[string]interface{} {
	result := make(map[string]interface{})

	for key, raw := range probe {
		var value interface{}
		if err := json.Unmarshal(raw, &value); err != nil {
			// Handle or skip on error
			continue
		}
		result[key] = value
	}

	return &result
}

// Custom unmarshaller for s3FormatLog
func (s *s3FormatLog) UnmarshalJSON(data []byte) error {
	type Alias s3FormatLog
	aux := &struct {
		Message json.RawMessage `json:"message"`
		*Alias
	}{
		Alias: (*Alias)(s),
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("error unmarshalling base struct: %w", err)
	}

	// Try unmarshalling message as string
	var strMsg string
	if err := json.Unmarshal(aux.Message, &strMsg); err == nil {
		s.Message = &strMsg
		return nil
	}

	// Else fallback to raw JSON object (e.g., {"time": ..., ...})
	rawMsg := string(aux.Message)
	s.Message = &rawMsg
	return nil
}

// parseLambdaPainTextLog handles the legacy plain text format for Lambda system logs
// These include START, END, and REPORT messages that aren't in JSON format
// Example:
// START RequestId: 8b133862-5331-4ded-ac5d-1ad5da5aee81
// END RequestId: 8b133862-5331-4ded-ac5d-1ad5da5aee81
// REPORT RequestId: 8b133862-5331-4ded-ac5d-1ad5da5aee81 Duration: 123.45 ms Billed Duration: 124 ms Memory Size: 128 MB Max Memory Used: 84 MB
func parseLambdaPainTextLog(line string, log *LambdaLog) (*LambdaLog, error) {
	if id := extractAfter(line, "RequestId: "); id != "" {
		log.RequestID = &id
	}
	switch {
	case strings.HasPrefix(line, "START RequestId:"):
		// Parse START log line
		log.LogType = ptr("START")
		if id := extractAfter(line, "START RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
			if len(strings.Split(line, "RequestId: "+id)[1]) > 0 {
				log.Message = &strings.Split(line, "RequestId: "+id)[1]
			}
		} else {
			log.Message = ptr(line)
		}
	case strings.HasPrefix(line, "INIT_START"):
		// Parse START log line
		log.LogType = ptr("INIT_START")
		if id := extractAfter(line, "INIT_START RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
			if len(strings.Split(line, "RequestId: "+id)[1]) > 0 {
				log.Message = &strings.Split(line, "RequestId: "+id)[1]
			}
		} else {
			msg := strings.Split(line, "INIT_START "+id)[1]
			log.Message = &msg
		}
	case strings.HasPrefix(line, "END RequestId:"):
		// Parse END log line
		log.LogType = ptr("END")
		if id := extractAfter(line, "END RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
			if len(strings.Split(line, "RequestId: "+id)[1]) > 0 {
				log.Message = &strings.Split(line, "RequestId: "+id)[1]
			}
		} else {
			log.Message = ptr(line)
		}
	case strings.HasPrefix(line, "REPORT RequestId:"):
		// Parse REPORT log line which contains metrics
		log.LogType = ptr("REPORT")

		// Extract RequestId
		if id := extractAfter(line, "REPORT RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
		}

		// Extract numeric metrics from REPORT line
		if val := extractBetween(line, "Duration: ", " ms"); val != "" {
			if f, err := strconv.ParseFloat(val, 64); err == nil {
				log.Duration = &f
			}
		}
		if val := extractBetween(line, "Billed Duration: ", " ms"); val != "" {
			if f, err := strconv.ParseFloat(val, 64); err == nil {
				log.BilledDuration = &f
			}
		}
		if val := extractBetween(line, "Memory Size: ", " MB"); val != "" {
			if i, err := strconv.Atoi(val); err == nil {
				log.MemorySize = &i
			}
		}
		if val := extractBetween(line, "Max Memory Used: ", " MB"); val != "" {
			if i, err := strconv.Atoi(val); err == nil {
				log.MaxMemoryUsed = &i
			}
		}

	case strings.HasPrefix(line, "EXTENSION"):
		// Parse START log line
		log.LogType = ptr("EXTENSION")
		if len(strings.Split(line, "EXTENSION")[1]) > 0 {
			log.Message = ptr(strings.TrimSpace(strings.Split(line, "EXTENSION")[1]))
		}

	case strings.HasPrefix(line, "TELEMETRY"):
		// Parse START log line
		log.LogType = ptr("TELEMETRY")
		if len(strings.Split(line, "TELEMETRY")[1]) > 0 {
			log.Message = ptr(strings.TrimSpace(strings.Split(line, "TELEMETRY")[1]))
		}

	default:
		log.Message = ptr(line)
	}

	return log, nil
}

// ptr is a helper function to return a pointer to a value
func ptr[T any](v T) *T {
	return &v
}

// extractAfter extracts substring that comes after a specific prefix
func extractAfter(s, prefix string) string {
	idx := strings.Index(s, prefix)
	if idx == -1 {
		return ""
	}
	return strings.TrimSpace(s[idx+len(prefix):])
}

// extractBetween extracts substring between start and end strings
func extractBetween(s, start, end string) string {
	i := strings.Index(s, start)
	if i == -1 {
		return ""
	}
	i += len(start)
	j := strings.Index(s[i:], end)
	if j == -1 {
		return ""
	}
	return strings.TrimSpace(s[i : i+j])
}

func isParsableJson(message interface{}) *map[string]interface{} {
	var raw interface{}

	switch v := message.(type) {
	case string:
		// Try unmarshalling the JSON string directly
		if err := json.Unmarshal([]byte(v), &raw); err != nil {
			return nil
		}
	default:
		// Marshal to JSON bytes
		jsonData, err := json.Marshal(message)
		if err != nil {
			return nil
		}
		if err := json.Unmarshal(jsonData, &raw); err != nil {
			return nil
		}
	}

	// Try asserting to map[string]interface{}
	if parsedMap, ok := raw.(map[string]interface{}); ok {
		return &parsedMap
	}

	return nil
}

// isTimestamp checks if the input string matches any common Go time formats.
// Used to identify if a plain text log starts with a timestamp
func isTimestamp(s string) bool {
	layouts := []string{
		time.RFC3339,
		time.RFC3339Nano,
		time.RFC1123,
		time.RFC1123Z,
		time.RFC822,
		time.RFC822Z,
		time.RFC850,
		"2006-01-02 15:04:05",        // Common log format
		"2006-01-02 15:04:05.000000", // With microseconds
		"2006-01-02T15:04:05",        // ISO-like without timezone
		"2006-01-02T15:04:05Z07:00",  // ISO with TZ offset
		"20060102T150405Z",           // AWS style compact
	}

	for _, layout := range layouts {
		if _, err := time.Parse(layout, s); err == nil {
			return true
		}
	}

	return false
}
