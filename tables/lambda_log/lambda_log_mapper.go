package lambda_log

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/turbot/tailpipe-plugin-sdk/mappers"
	cwTypes "github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs/types"
)

type LambdaLogMapper struct {
}

func (m *LambdaLogMapper) Identifier() string {
	return "lambda_log_mapper"
}

// JSON format for system logs as described in AWS docs
// Contains "time", "type", and "record" fields
// System logs are sometimes known as platform event logs
// https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs-advanced.html#monitoring-cloudwatchlogs-logformat
type jsonFormatSystemLog struct {
	Time   string                 `json:"time"`
	Type   string                 `json:"type"`
	Record map[string]interface{} `json:"record"`
}

// JSON format for application logs as described in AWS docs
// Contains "timestamp", "level", "message", and "requestId" fields
// Generated by Lambda functions using supported logging methods
// https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs-advanced.html#monitoring-cloudwatchlogs-logformat
type jsonFormatApplicationLog struct {
	Timestamp string `json:"timestamp"`
	Level     string `json:"level"`
	Message   string `json:"message"`
	RequestID string `json:"requestId"`
}

// While storing the logs in the S3 bucket, the logs are stored in the following format:
type s3FormatLog struct {
	AccountId *string `json:"accountId"`
	LogGroup  *string `json:"logGroup"`
	LogStream *string `json:"logStream"`
	Id        *string `json:"id"`
	Timestamp *int64  `json:"timestamp"`
	Message   *string `json:"message"`
}

func (m *LambdaLogMapper) Map(_ context.Context, a any, _ ...mappers.MapOption[*LambdaLog]) (*LambdaLog, error) {
	row := &LambdaLog{}
	isCwLog := false

	var raw string
	switch v := a.(type) {
	case []byte:
		raw = string(v)
	case string:
		raw = v
	case *string:
		raw = *v
	case cwTypes.FilteredLogEvent:
		raw = *v.Message
		t := time.UnixMilli(*v.Timestamp)
		row.Timestamp = &t
		isCwLog = true
	default:
		return nil, fmt.Errorf("expected string or []byte, got %T", a)
	}

	// Handle S3 bucket logs
	s3Format := &s3FormatLog{}
	isTextFormat := true
	if err := s3Format.UnmarshalJSON([]byte(raw)); err == nil && !isCwLog {
		// if s3Format.LogGroup != nil {
		// if row.TpTimestamp.IsZero() {
		slog.Error("S3 format log", "Timestamp", *s3Format.Timestamp)
		t := time.UnixMilli(*s3Format.Timestamp)
		slog.Error("S3 format log", "Timestamp", *s3Format.Timestamp, "Time", t)
		if err == nil {
			row.Timestamp = &t
		}

		if s3Format.LogGroup != nil {
			row.LogGroupName = s3Format.LogGroup
		}

		// raw = strings.TrimSpace(*s3Format.Message)
		msgStr, err := strconv.Unquote(*s3Format.Message)
		if err == nil {
			isTextFormat = true
			raw = strings.TrimSpace(msgStr)
		}
		if err != nil {
			// In the case if the message is a JSON object we will not have the unescape character.
			isTextFormat = false
			raw = strings.TrimSpace(*s3Format.Message)
			slog.Error("Error unquoting message", "error", err)
		}
	}

	raw = strings.TrimSpace(raw)
	if strings.HasPrefix(raw, "REPORT") || strings.HasPrefix(raw, "END") || strings.HasPrefix(raw, "START") || strings.HasPrefix(raw, "INIT_START") || strings.HasPrefix(raw, "EXTENSION") || strings.HasPrefix(raw, "TELEMETRY") || (isTextFormat && !isTimestamp(strings.Fields(raw)[0])){
		lambdaLog, err := parseLambdaPainTextLog(raw)
		if err != nil {
			return nil, fmt.Errorf("error parsing lambda pain text log: %w", err)
		}
		lambdaLog.Timestamp = row.Timestamp
		lambdaLog.RawMessage = &raw
		return lambdaLog, nil
	}

	// First unmarshal into a minimal structure to detect log type
	var probe map[string]json.RawMessage
	if err := json.Unmarshal([]byte(raw), &probe); err == nil {
		// Check for system log keys (platform events with time, type, record structure)
		if _, hasType := probe["type"]; hasType {
			var systemLog jsonFormatSystemLog
			if err := json.Unmarshal([]byte(raw), &systemLog); err != nil {
				return nil, fmt.Errorf("error unmarshalling as system log: %w", err)
			}

			// Parse system log fields based on AWS JSON format for system logs
			if t, err := time.Parse(time.RFC3339, systemLog.Time); err == nil {
				row.Timestamp = &t
			}
			row.LogType = &systemLog.Type
			if msgBytes, err := json.Marshal(systemLog.Record); err == nil {
				message := string(msgBytes)
				row.Message = &message
			} else {
				// fallback in case of marshal error
				message := fmt.Sprintf("%v", systemLog.Record)
				row.Message = &message
			}

			// Extract specific fields from platform event record
			if requestId, ok := systemLog.Record["requestId"].(string); ok {
				row.RequestID = &requestId
			}
			// Extract metrics from platform.report events
			if metrics, ok := systemLog.Record["metrics"].(map[string]interface{}); ok {
				if v, ok := metrics["durationMs"].(float64); ok {
					row.Duration = &v
				}
				if v, ok := metrics["billedDurationMs"].(float64); ok {
					row.BilledDuration = &v
				}
				if v, ok := metrics["memorySizeMB"].(float64); ok {
					mem := int(v)
					row.MemorySize = &mem
				}
				if v, ok := metrics["maxMemoryUsedMB"].(float64); ok {
					mem := int(v)
					row.MaxMemoryUsed = &mem
				}
			}
			row.RawMessage = &raw
			return row, nil
		} else if _, hasLevel := probe["level"]; hasLevel {
			// Fallback to application log (JSON format with timestamp, level, message, requestId)
			var appLog jsonFormatApplicationLog
			if err := json.Unmarshal([]byte(raw), &appLog); err != nil {
				return nil, fmt.Errorf("error unmarshalling as application log: %w", err)
			}

			// Parse application log fields based on AWS JSON format for app logs
			if t, err := time.Parse(time.RFC3339, appLog.Timestamp); err == nil {
				row.Timestamp = &t
			}
			row.LogLevel = &appLog.Level
			row.Message = &appLog.Message
			row.RequestID = &appLog.RequestID
			row.RawMessage = &raw	
			return row, nil
		}
	} 
	if len(strings.Fields(raw)) >= 4 && isTimestamp(strings.Fields(raw)[0]) { // plain text application log
		// Handle plain text application logs (format: timestamp requestID logLevel message)
		// Example: 2024-10-27T19:17:45.586Z 79b4f56e-95b1-4643-9700-2807f4e68189 INFO some log message
		// [INFO]	2025-05-26T06:42:27.551Z	66e2e287-e14b-471e-8185-faca26d2c310	This is a function log
		fields := strings.Fields(raw)
		// Timestamp
		if t, err := time.Parse(time.RFC3339, fields[0]); err == nil {
			row.Timestamp = &t
		}
		// RequestID
		var uuidRegex = regexp.MustCompile(`^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$`)
		if uuidRegex.MatchString(fields[1]) {
			row.RequestID = &fields[1]
		}
		// LogLevel
		if slices.Contains([]string{"INFO", "DEBUG", "WARN", "ERROR", "FATAL", "TRACE", ""}, fields[2]) {
			row.LogLevel = &fields[2]
		}
		// Message
		if len(fields) >= 4 {
			msg := strings.Join(fields[3:], " ")
			row.Message = &msg
		}
		row.RawMessage = &raw
	} else {
		row.Message = &raw
		row.RawMessage = &raw
	}

	return row, nil
}

func (s *s3FormatLog) UnmarshalJSON(data []byte) error {
	type Alias s3FormatLog
	aux := &struct {
		Message json.RawMessage `json:"message"`
		*Alias
	}{
		Alias: (*Alias)(s),
	}

	// slog.Error("U11111111111", "data", string(data))
	if err := json.Unmarshal(data, &aux); err != nil {
		slog.Error("Error unmarshalling s3 format log", "error", err)
		return err
	}

	msgStr := string(aux.Message)
	s.Message = &msgStr
	// slog.Error("22222222222222", "data", string(msgStr))
	return nil
}

// parseLambdaPainTextLog handles the legacy plain text format for Lambda system logs
// These include START, END, and REPORT messages that aren't in JSON format
// Example:
// START RequestId: 8b133862-5331-4ded-ac5d-1ad5da5aee81
// END RequestId: 8b133862-5331-4ded-ac5d-1ad5da5aee81
// REPORT RequestId: 8b133862-5331-4ded-ac5d-1ad5da5aee81 Duration: 123.45 ms Billed Duration: 124 ms Memory Size: 128 MB Max Memory Used: 84 MB
func parseLambdaPainTextLog(line string) (*LambdaLog, error) {
	log := &LambdaLog{}
	if id := extractAfter(line, "RequestId: "); id != "" {
		log.RequestID = &id
	}
	// TODO: Handle other Platform event type of logs if any.
	// https://docs.aws.amazon.com/lambda/latest/dg/telemetry-api.html
	switch {
	case strings.HasPrefix(line, "START RequestId:"):
		// Parse START log line
		log.LogType = ptr("START")
		if id := extractAfter(line, "START RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
			if len(strings.Split(line, "RequestId: "+id)[1]) > 0 {
				log.Message = &strings.Split(line, "RequestId: "+id)[1]
			}
		} else {
			log.Message = ptr(line)
		}
	case strings.HasPrefix(line, "INIT_START"):
		// Parse START log line
		log.LogType = ptr("INIT_START")
		if id := extractAfter(line, "INIT_START RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
			if len(strings.Split(line, "RequestId: "+id)[1]) > 0 {
				log.Message = &strings.Split(line, "RequestId: "+id)[1]
			}
		} else {
			msg := strings.Split(line, "INIT_START "+id)[1]
			log.Message = &msg
		}
	case strings.HasPrefix(line, "END RequestId:"):
		// Parse END log line
		log.LogType = ptr("END")
		if id := extractAfter(line, "END RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
			if len(strings.Split(line, "RequestId: "+id)[1]) > 0 {
				log.Message = &strings.Split(line, "RequestId: "+id)[1]
			}
		} else {
			log.Message = ptr(line)
		}
	case strings.HasPrefix(line, "REPORT RequestId:"):
		// Parse REPORT log line which contains metrics
		log.LogType = ptr("REPORT")

		// Extract RequestId
		if id := extractAfter(line, "REPORT RequestId: "); id != "" {
			log.RequestID = ptr(strings.Fields(id)[0])
		}

		// Extract numeric metrics from REPORT line
		if val := extractBetween(line, "Duration: ", " ms"); val != "" {
			if f, err := strconv.ParseFloat(val, 64); err == nil {
				log.Duration = &f
			}
		}
		if val := extractBetween(line, "Billed Duration: ", " ms"); val != "" {
			if f, err := strconv.ParseFloat(val, 64); err == nil {
				log.BilledDuration = &f
			}
		}
		if val := extractBetween(line, "Memory Size: ", " MB"); val != "" {
			if i, err := strconv.Atoi(val); err == nil {
				log.MemorySize = &i
			}
		}
		if val := extractBetween(line, "Max Memory Used: ", " MB"); val != "" {
			if i, err := strconv.Atoi(val); err == nil {
				log.MaxMemoryUsed = &i
			}
		}

	case strings.HasPrefix(line, "EXTENSION"):
		// Parse START log line
		log.LogType = ptr("EXTENSION")
		log.RequestID = ptr(strings.Fields("EXTENSION")[0])
		if len(strings.Split(line, "EXTENSION")[1]) > 0 {
			log.Message = ptr(strings.TrimSpace(strings.Split(line, "EXTENSION")[1]))
		}

	case strings.HasPrefix(line, "TELEMETRY"):
		// Parse START log line
		log.LogType = ptr("TELEMETRY")
		log.RequestID = ptr(strings.Fields("TELEMETRY")[0])
		if len(strings.Split(line, "TELEMETRY")[1]) > 0 {
			log.Message = ptr(strings.TrimSpace(strings.Split(line, "TELEMETRY")[1]))
		}

	default:
		log.Message = ptr(line)
	}

	return log, nil
}

// ptr is a helper function to return a pointer to a value
func ptr[T any](v T) *T {
	return &v
}

// extractAfter extracts substring that comes after a specific prefix
func extractAfter(s, prefix string) string {
	idx := strings.Index(s, prefix)
	if idx == -1 {
		return ""
	}
	return strings.TrimSpace(s[idx+len(prefix):])
}

// extractBetween extracts substring between start and end strings
func extractBetween(s, start, end string) string {
	i := strings.Index(s, start)
	if i == -1 {
		return ""
	}
	i += len(start)
	j := strings.Index(s[i:], end)
	if j == -1 {
		return ""
	}
	return strings.TrimSpace(s[i : i+j])
}

// isTimestamp checks if the input string matches any common Go time formats.
// Used to identify if a plain text log starts with a timestamp
func isTimestamp(s string) bool {
	layouts := []string{
		time.RFC3339,
		time.RFC3339Nano,
		time.RFC1123,
		time.RFC1123Z,
		time.RFC822,
		time.RFC822Z,
		time.RFC850,
		"2006-01-02 15:04:05",        // Common log format
		"2006-01-02 15:04:05.000000", // With microseconds
		"2006-01-02T15:04:05",        // ISO-like without timezone
		"2006-01-02T15:04:05Z07:00",  // ISO with TZ offset
		"20060102T150405Z",           // AWS style compact
	}

	for _, layout := range layouts {
		if _, err := time.Parse(layout, s); err == nil {
			return true
		}
	}

	return false
}

// Commented out legacy code
// rawRow = strings.TrimSuffix(rawRow, "\n")
// 	fields := strings.Fields(rawRow)

// 	switch fields[0] {
// 	case "START", "END":
// 		row.LogType = &fields[0]
// 		row.RequestID = &fields[2]
// 	case "REPORT":
// 		row.LogType = &fields[0]
// 		row.RequestID = &fields[2]
// 		duration, err := strconv.ParseFloat(fields[4], 64)
// 		if err != nil {
// 			return nil, fmt.Errorf("error parsing duration: %w", err)
// 		}
// 		row.Duration = &duration
// 		billed, err := strconv.ParseFloat(fields[8], 64)
// 		if err != nil {
// 			return nil, fmt.Errorf("error parsing billed duration: %w", err)
// 		}
// 		row.BilledDuration = &billed
// 		mem, err := strconv.Atoi(fields[12])
// 		if err != nil {
// 			return nil, fmt.Errorf("error parsing memory size: %w", err)
// 		}
// 		row.MemorySize = &mem
// 		maxMem, err := strconv.Atoi(fields[17])
// 		if err != nil {
// 			return nil, fmt.Errorf("error parsing max memory used: %w", err)
// 		}
// 		row.MaxMemoryUsed = &maxMem
// 	default:
// 		t := "LOG"
// 		row.LogType = &t

// 		ts, err := time.Parse(time.RFC3339, fields[0])
// 		if err != nil {
// 			return nil, fmt.Errorf("error parsing timestamp: %w", err)
// 		}
// 		row.Timestamp = &ts

// 		row.RequestID = &fields[1]
// 		row.LogLevel = &fields[2]
// 		strip := fmt.Sprintf("%s%s", strings.Join(fields[:3], "\t"), "\t")
// 		stripped := strings.TrimPrefix(rawRow, strip)
// 		row.Message = &stripped
// 	}
